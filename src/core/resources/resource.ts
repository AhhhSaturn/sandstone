import type { SandstoneCommands } from 'sandstone/commands/commands'
import type { Node, SandstoneCore } from '#core'
import type { PackType, ResourcePath, SandstonePack } from '#pack'
import type { BASIC_CONFLICT_STRATEGIES, LiteralUnion, MakeInstanceCallable } from '#utils'

export type ResourceClassArguments = {
  /**
   * Whether the associated Node should be added to Sandstone Core.
   */
  addToSandstoneCore: boolean

  /**
   * Whether the MCFunction has been created explicitely by a user, or automatically generated by Sandstone.
   */
  creator: 'user' | 'sandstone'

  // TODO: Remove the optional part!
  onConflict?: LiteralUnion<BASIC_CONFLICT_STRATEGIES>
}

export type ResourceNode<T = ResourceClass<any>> = Node & {
  resource: T
}

export type ResourceNodeConstructor<N extends Node> = new (sandstoneCore: SandstoneCore, resource: any) => N

export abstract class ResourceClass<N extends ResourceNode = ResourceNode<any>> {
  protected node: N

  packType

  fileExtension

  fileEncoding

  protected creator: NonNullable<ResourceClassArguments['creator']>

  protected commands: SandstoneCommands

  protected pack: SandstonePack

  path

  onConflict: LiteralUnion<BASIC_CONFLICT_STRATEGIES>

  constructor(protected core: SandstoneCore, packType: PackType, fileExtension: string, fileEncoding: string, NodeType: ResourceNodeConstructor<N>, path: ResourcePath, args: ResourceClassArguments) {
    this.node = new NodeType(core, this)

    this.packType = packType

    this.fileExtension = fileExtension
    this.fileEncoding = fileEncoding

    this.pack = core.pack
    this.commands = core.pack.commands

    this.path = path

    if (args.addToSandstoneCore) {
      core.resourceNodes.add(this.node)
    }

    this.creator = args.creator ?? 'sandstone'
    this.onConflict = args.onConflict ?? 'throw'
  }

  protected getNode = () => this.node

  get name(): string {
    return `${this.path[0]}:${this.path.slice(1).join('/')}`
  }

  protected generate = () => {}

  toString(): string {
    return this.name
  }
}

export abstract class CallableResourceClass<N extends ResourceNode = ResourceNode<any>> extends ResourceClass<N> {
  // This is the resource, but as a callable
  private _that: MakeInstanceCallable<this> | undefined

  protected get asCallable() {
    if (!this._that) {
      throw new Error('Class has not been made callable.')
    }
    return this._that
  }

  private makeCallable(mcFunctionClass: this & this['__call__']) {
    this._that = mcFunctionClass
    this.node.resource = mcFunctionClass
  }

  abstract __call__: (...args: any) => any
}
