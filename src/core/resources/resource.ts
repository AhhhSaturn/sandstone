/* eslint-disable multiline-comment-style */
import type { SandstoneCommands } from 'sandstone/commands/commands'
import type { Node, SandstoneCore } from '#core'
import type { PackType, ResourcePath, SandstonePack } from '#pack'
import type { BASIC_CONFLICT_STRATEGIES, LiteralUnion, MakeInstanceCallable } from '#utils'

export type ResourceClassArguments<ConflictType extends 'default' | 'list' | 'function'> = {
  /**
   * Whether the associated Node should be added to Sandstone Core.
   */
  addToSandstoneCore: boolean

  /**
   * Whether the resource has been created explicitely by a user, or automatically generated by Sandstone.
   */
  creator: 'user' | 'sandstone'

  /**
   * What to do if another resource of the same type has the same name.
   *
   * - `throw`: Throw an error.
   * - `replace`: Replace silently the old resource with the new one.
   * - `ignore`: Keep silently the old resource, discarding the new one.
   * - `append`: Append the new resource entries to the old one.
   * - `prepend`: Prepend the new resource entries to the old one.
   * - `rename`: Rename the new file to an iterating number (ie. func1, func2, func3)
   */
  // eslint-disable-next-line max-len
  onConflict?: ConflictType extends 'default' ? BASIC_CONFLICT_STRATEGIES : ConflictType extends 'list' ? BASIC_CONFLICT_STRATEGIES | 'append' | 'prepend' : BASIC_CONFLICT_STRATEGIES | 'append' | 'prepend' | 'rename'
}

export type ResourceNode<T = ResourceClass<any>> = Node & {
  resource: T
}

export type ResourceNodeConstructor<N extends Node> = new (sandstoneCore: SandstoneCore, resource: any) => N

export abstract class ResourceClass<N extends ResourceNode = ResourceNode<any>> {
  protected node: N

  packType

  fileExtension

  protected creator: NonNullable<ResourceClassArguments<any>['creator']>

  protected commands: SandstoneCommands

  protected pack: SandstonePack

  path

  onConflict: LiteralUnion<BASIC_CONFLICT_STRATEGIES> | ((oldResource: ResourceNode, newResource: ResourceNode) => void)

  // eslint-disable-next-line max-len
  constructor(protected core: SandstoneCore, packType: PackType, fileExtension: string, NodeType: ResourceNodeConstructor<N>, path: ResourcePath, args: ResourceClassArguments<any>) {
    this.node = new NodeType(core, this)

    this.packType = packType

    this.fileExtension = fileExtension

    this.pack = core.pack
    this.commands = core.pack.commands

    this.path = path

    this.onConflict = args.onConflict ?? 'throw'

    if (args.addToSandstoneCore) {
      // TODO: Add conflict handling

      // if (this instanceof MCFunctionClass) {
      //   if (this.onConflict === 'prepend') {
      //     this.onConflict = (_oldFunc, _newFunc) => {
      //       const oldFunc = _oldFunc as MCFunctionNode
      //       const newFunc = _newFunc as MCFunctionNode

      //       oldFunc.prependNode(newFunc.body)
      //     }
      //   }
      //   if (this.onConflict === 'append') {
      //     this.onConflict = (_oldFunc, _newFunc) => {
      //       const oldFunc = _oldFunc as MCFunctionNode
      //       const newFunc = _newFunc as MCFunctionNode

      //       oldFunc.appendNode(newFunc.body)
      //     }
      //   }
      // }
      core.resourceNodes.add(this.node)
    }

    this.creator = args.creator ?? 'sandstone'
  }

  protected getNode = () => this.node

  get name(): string {
    return `${this.path[0]}:${this.path.slice(1).join('/')}`
  }

  protected generate = () => {}

  toString(): string {
    return this.name
  }
}

export abstract class CallableResourceClass<N extends ResourceNode = ResourceNode<any>> extends ResourceClass<N> {
  // This is the resource, but as a callable
  private _that: MakeInstanceCallable<this> | undefined

  protected get asCallable() {
    if (!this._that) {
      throw new Error('Class has not been made callable.')
    }
    return this._that
  }

  private makeCallable(mcFunctionClass: this & this['__call__']) {
    this._that = mcFunctionClass
    this.node.resource = mcFunctionClass
  }

  abstract __call__: (...args: any) => any
}
