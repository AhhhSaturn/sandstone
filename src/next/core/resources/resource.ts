import type { ResourcePath } from '@datapack/resourcesTree'
import type { Node, SandstoneCore } from '..'

export type ResourceClassArguments<THIS = ResourceClass> = {
  /**
   * Whether the associated Node should be added to Sandstone Core.
   *
   * @default true
   */
  addToSandstoneCore?: boolean

  /**
   * Whether the MCFunction has been created explicitely by a user, or automatically generated by Sandstone.
   *
   * @default 'sandstone'
   */
  creator?: 'user' | 'sandstone'

  /**
   * The optional parent of this resource.
   */
  parent?: THIS
}

export type ResourceNode<T = ResourceClass<any>> = Node & {
  resource: T
}

type ResourceNodeConstructor<N extends Node> = new (sandstoneCore: SandstoneCore, resource: any) => N

export abstract class ResourceClass<N extends ResourceNode = ResourceNode<any>> {
  protected generated: boolean

  protected node: N

  protected creator: NonNullable<ResourceClassArguments['creator']>

  protected parentResource: this | undefined

  protected childResources: Set<this> = new Set()

  constructor(sandstoneCore: SandstoneCore, NodeType: ResourceNodeConstructor<N>, protected path: ResourcePath, args: ResourceClassArguments = {}) {
    this.node = new NodeType(sandstoneCore, this)

    if (args.addToSandstoneCore) {
      sandstoneCore.resourceNodes.add(this.node)
    }

    this.generated = false
    this.creator = args.creator ?? 'sandstone'
    this.parentResource = args.parent as this | undefined
  }

  get name(): string {
    return `${this.path[0]}:${this.path.slice(1).join('/')}`
  }

  generate = () => {
    this.generated = true
  }

  toString(): string {
    return this.name
  }
}
